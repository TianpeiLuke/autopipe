{
  "script_name": "payload",
  "level1": {
    "passed": true,
    "issues": [],
    "script_analysis": {
      "script_path": "/Users/tianpeixie/github_workspace/cursus/src/cursus/steps/scripts/payload.py",
      "path_references": [
        "path='\\nMIMS Payload Generation Processing Script\\n\\nThis script reads field information from hyperparameters extracted from model.tar.gz,\\nextracts configuration from environment variables,\\nand creates payload files for model inference.\\n' line_number=2 context='#!/usr/bin/env python\\n>>> \"\"\"\\nMIMS Payload Generation Processing Script\\n' is_hardcoded=True construction_method=None",
        "path='/opt/ml/processing/input/model' line_number=29 context='\\n# Fixed input/output directories\\n>>> INPUT_MODEL_DIR = \"/opt/ml/processing/input/model\"\\nOUTPUT_DIR = Path(\"/opt/ml/processing/output\")\\nWORKING_DIRECTORY = Path(\"/tmp/mims_payload_work\")' is_hardcoded=True construction_method=None",
        "path='/opt/ml/processing/output' line_number=30 context='# Fixed input/output directories\\nINPUT_MODEL_DIR = \"/opt/ml/processing/input/model\"\\n>>> OUTPUT_DIR = Path(\"/opt/ml/processing/output\")\\nWORKING_DIRECTORY = Path(\"/tmp/mims_payload_work\")\\nPAYLOAD_SAMPLE_DIR = WORKING_DIRECTORY / \"payload_sample\"' is_hardcoded=True construction_method=None",
        "path='/tmp/mims_payload_work' line_number=31 context='INPUT_MODEL_DIR = \"/opt/ml/processing/input/model\"\\nOUTPUT_DIR = Path(\"/opt/ml/processing/output\")\\n>>> WORKING_DIRECTORY = Path(\"/tmp/mims_payload_work\")\\nPAYLOAD_SAMPLE_DIR = WORKING_DIRECTORY / \"payload_sample\"\\n' is_hardcoded=True construction_method=None",
        "path='Ensure a directory exists, creating it if necessary.' line_number=40 context='\\ndef ensure_directory(directory_path):\\n>>>     \"\"\"Ensure a directory exists, creating it if necessary.\"\"\"\\n    try:\\n        if isinstance(directory_path, str):' is_hardcoded=True construction_method=None",
        "path='model.tar.gz' line_number=96 context='    # The builder step has been updated to use the directory as destination, not model.tar.gz\\n    # But we\\'ll keep the name for backward compatibility and handle both cases\\n>>>     input_model_path = Path(INPUT_MODEL_DIR) / \"model.tar.gz\"\\n    input_model_dir = Path(INPUT_MODEL_DIR)\\n    logger.info(f\"Looking for hyperparameters in model artifacts\")' is_hardcoded=True construction_method=None",
        "path='hyperparameters.json' line_number=114 context=\"                hyperparams_info = None\\n                for member in tar.getmembers():\\n>>>                     if member.name == 'hyperparameters.json':\\n                        hyperparams_info = member\\n                        break\" is_hardcoded=True construction_method=None",
        "path='hyperparameters.json' line_number=126 context='                    # Extract only the hyperparameters file\\n                    tar.extract(hyperparams_info, WORKING_DIRECTORY)\\n>>>                     hyperparams_path = WORKING_DIRECTORY / \"hyperparameters.json\"\\n        except Exception as e:\\n            logger.warning(f\"Error processing model.tar.gz as tarfile: {e}\")' is_hardcoded=True construction_method=None",
        "path='hyperparameters.json' line_number=134 context='    if hyperparams_path is None and input_model_path.exists() and input_model_path.is_dir():\\n        logger.info(f\"{input_model_path} is a directory, looking for hyperparameters.json inside\")\\n>>>         direct_hyperparams_path = input_model_path / \"hyperparameters.json\"\\n        if direct_hyperparams_path.exists():\\n            logger.info(f\"Found hyperparameters.json directly in the model.tar.gz directory\")' is_hardcoded=True construction_method=None",
        "path='hyperparameters.json' line_number=142 context='    if hyperparams_path is None:\\n        logger.info(f\"Looking for hyperparameters.json directly in {input_model_dir}\")\\n>>>         direct_hyperparams_path = input_model_dir / \"hyperparameters.json\"\\n        if direct_hyperparams_path.exists():\\n            logger.info(f\"Found hyperparameters.json directly in the input model directory\")' is_hardcoded=True construction_method=None",
        "path='hyperparameters.json' line_number=150 context='    if hyperparams_path is None:\\n        logger.info(f\"Searching recursively for hyperparameters.json in {input_model_dir}\")\\n>>>         for path in input_model_dir.rglob(\"hyperparameters.json\"):\\n            hyperparams_path = path\\n            logger.info(f\"Found hyperparameters.json at {hyperparams_path}\")' is_hardcoded=True construction_method=None",
        "path='hyperparameters.json' line_number=170 context='    if not str(hyperparams_path).startswith(str(WORKING_DIRECTORY)):\\n        import shutil\\n>>>         dest_path = WORKING_DIRECTORY / \"hyperparameters.json\"\\n        shutil.copy2(hyperparams_path, dest_path)\\n        ' is_hardcoded=True construction_method=None",
        "path='Get content types from environment variables.' line_number=177 context='\\ndef get_environment_content_types() -> List[str]:\\n>>>     \"\"\"Get content types from environment variables.\"\"\"\\n    content_types_str = os.environ.get(ENV_CONTENT_TYPES, \"application/json\")\\n    return [ct.strip() for ct in content_types_str.split(\\',\\')]' is_hardcoded=True construction_method=None",
        "path='Get default numeric value from environment variables.' line_number=182 context='\\ndef get_environment_default_numeric_value() -> float:\\n>>>     \"\"\"Get default numeric value from environment variables.\"\"\"\\n    try:\\n        return float(os.environ.get(ENV_DEFAULT_NUMERIC_VALUE, \"0.0\"))' is_hardcoded=True construction_method=None",
        "path='0.0' line_number=184 context='    \"\"\"Get default numeric value from environment variables.\"\"\"\\n    try:\\n>>>         return float(os.environ.get(ENV_DEFAULT_NUMERIC_VALUE, \"0.0\"))\\n    except ValueError:\\n        logger.warning(f\"Invalid {ENV_DEFAULT_NUMERIC_VALUE}, using default 0.0\")' is_hardcoded=True construction_method=None",
        "path=', using default 0.0' line_number=186 context='        return float(os.environ.get(ENV_DEFAULT_NUMERIC_VALUE, \"0.0\"))\\n    except ValueError:\\n>>>         logger.warning(f\"Invalid {ENV_DEFAULT_NUMERIC_VALUE}, using default 0.0\")\\n        return 0.0\\n' is_hardcoded=True construction_method=None",
        "path='Get default text value from environment variables.' line_number=190 context='\\ndef get_environment_default_text_value() -> str:\\n>>>     \"\"\"Get default text value from environment variables.\"\"\"\\n    return os.environ.get(ENV_DEFAULT_TEXT_VALUE, \"DEFAULT_TEXT\")\\n' is_hardcoded=True construction_method=None",
        "path='Get special field values from environment variables.' line_number=194 context='\\ndef get_environment_special_fields() -> Dict[str, str]:\\n>>>     \"\"\"Get special field values from environment variables.\"\"\"\\n    special_fields = {}\\n    for env_var, env_value in os.environ.items():' is_hardcoded=True construction_method=None",
        "path='.csv' line_number=356 context='        \\n        # Determine file extension and name\\n>>>         ext = \".csv\" if content_type == \"text/csv\" else \".json\"\\n        file_name = f\"payload_{content_type.replace(\\'/\\', \\'_\\')}_{i}{ext}\"\\n        file_path = output_dir / file_name' is_hardcoded=True construction_method=None",
        "path='.json' line_number=356 context='        \\n        # Determine file extension and name\\n>>>         ext = \".csv\" if content_type == \"text/csv\" else \".json\"\\n        file_name = f\"payload_{content_type.replace(\\'/\\', \\'_\\')}_{i}{ext}\"\\n        file_path = output_dir / file_name' is_hardcoded=True construction_method=None",
        "path='payload.tar.gz' line_number=387 context='    \"\"\"\\n    # Create archive in the output directory\\n>>>     archive_path = Path(OUTPUT_DIR) / \"payload.tar.gz\"\\n    \\n    # Ensure parent directory exists (but not the actual archive path)' is_hardcoded=True construction_method=None",
        "path='.2f' line_number=407 context='                total_size += size_mb\\n                files_added += 1\\n>>>                 logger.info(f\"Adding to tar: {file_name} ({size_mb:.2f}MB)\")\\n                tar.add(file_path, arcname=file_name)\\n        ' is_hardcoded=True construction_method=None",
        "path='.2f' line_number=412 context='        logger.info(f\"Tar creation summary:\")\\n        logger.info(f\"  Files added: {files_added}\")\\n>>>         logger.info(f\"  Total uncompressed size: {total_size:.2f}MB\")\\n        \\n        # Verify archive was created' is_hardcoded=True construction_method=None",
        "path='.2f' line_number=418 context='            compressed_size = archive_path.stat().st_size / (1024 * 1024)\\n            logger.info(f\"Successfully created payload archive: {archive_path}\")\\n>>>             logger.info(f\"  Compressed tar size: {compressed_size:.2f}MB\")\\n            logger.info(f\"  Compression ratio: {compressed_size/total_size:.2%}\")\\n        else:' is_hardcoded=True construction_method=None",
        "path='.2%' line_number=419 context='            logger.info(f\"Successfully created payload archive: {archive_path}\")\\n            logger.info(f\"  Compressed tar size: {compressed_size:.2f}MB\")\\n>>>             logger.info(f\"  Compression ratio: {compressed_size/total_size:.2%}\")\\n        else:\\n            logger.error(f\"Archive creation failed - file does not exist: {archive_path}\")' is_hardcoded=True construction_method=None",
        "path='Main entry point for the script.' line_number=430 context='\\ndef main():\\n>>>     \"\"\"Main entry point for the script.\"\"\"\\n    # Extract hyperparameters from model tarball\\n    hyperparams = extract_hyperparameters_from_tarball()' is_hardcoded=True construction_method=None",
        "path='1.0.0' line_number=456 context=\"    # Extract pipeline name and version from hyperparams\\n    pipeline_name = hyperparams.get('pipeline_name', 'default_pipeline')\\n>>>     pipeline_version = hyperparams.get('pipeline_version', '1.0.0')\\n    model_objective = hyperparams.get('model_registration_objective', None)\\n    \" is_hardcoded=True construction_method=None",
        "path='MIMS payload generation complete.' line_number=479 context='    \\n    # Log summary information about the payload generation\\n>>>     logger.info(f\"MIMS payload generation complete.\")\\n    logger.info(f\"Number of payload samples generated: {len(payload_file_paths)}\")\\n    logger.info(f\"Content types: {content_types}\")' is_hardcoded=True construction_method=None"
      ],
      "env_var_accesses": [],
      "imports": [
        "module_name='json' import_alias=None line_number=9 is_from_import=False imported_items=[]",
        "module_name='logging' import_alias=None line_number=10 is_from_import=False imported_items=[]",
        "module_name='os' import_alias=None line_number=11 is_from_import=False imported_items=[]",
        "module_name='tarfile' import_alias=None line_number=12 is_from_import=False imported_items=[]",
        "module_name='tempfile' import_alias=None line_number=13 is_from_import=False imported_items=[]",
        "module_name='pathlib' import_alias=None line_number=14 is_from_import=True imported_items=['Path']",
        "module_name='enum' import_alias=None line_number=15 is_from_import=True imported_items=['Enum']",
        "module_name='typing' import_alias=None line_number=16 is_from_import=True imported_items=['List', 'Dict', 'Any', 'Union']",
        "module_name='datetime' import_alias=None line_number=17 is_from_import=True imported_items=['datetime']",
        "module_name='shutil' import_alias=None line_number=169 is_from_import=False imported_items=[]"
      ],
      "argument_definitions": [],
      "file_operations": [
        "file_path='<file_object>' operation_type='read' line_number=165 context=\"    # Load the hyperparameters\\n    with open(hyperparams_path, 'r') as f:\\n>>>         hyperparams = json.load(f)\\n    \\n    # Copy to working directory if not already there\" mode=None method='json.load'"
      ]
    },
    "contract": {
      "entry_point": "payload.py",
      "inputs": {
        "model_input": {
          "path": "/opt/ml/processing/input/model"
        }
      },
      "outputs": {
        "payload_sample": {
          "path": "/opt/ml/processing/output"
        }
      },
      "arguments": {},
      "environment_variables": {
        "required": [],
        "optional": {
          "CONTENT_TYPES": "application/json",
          "DEFAULT_NUMERIC_VALUE": "0.0",
          "DEFAULT_TEXT_VALUE": "DEFAULT_TEXT"
        }
      },
      "description": "\n    MIMS payload generation script that:\n    1. Extracts hyperparameters from model artifacts (model.tar.gz or directory)\n    2. Creates model variable list from field information\n    3. Generates sample payloads in multiple formats (JSON, CSV)\n    4. Archives payload files for deployment\n    \n    Note: This script extracts pipeline name, version, and model objective from hyperparameters,\n    not from environment variables. It does not use PIPELINE_NAME, REGION, PAYLOAD_S3_KEY, or \n    BUCKET_NAME environment variables.\n    \n    Input Structure:\n    - /opt/ml/processing/input/model: Model artifacts containing hyperparameters.json\n    \n    Output Structure:\n    - /tmp/mims_payload_work/payload_sample/: Sample payload files (temporary)\n    - /opt/ml/processing/output/: Output directory containing payload.tar.gz file\n    \n    Environment Variables:\n    - CONTENT_TYPES: Comma-separated list of content types (default: \"application/json\")\n    - DEFAULT_NUMERIC_VALUE: Default value for numeric fields (default: \"0.0\")\n    - DEFAULT_TEXT_VALUE: Default value for text fields (default: \"DEFAULT_TEXT\")\n    - SPECIAL_FIELD_<fieldname>: Custom values for specific fields\n    \n    Arguments:\n    - mode: Operating mode for the script (default: \"standard\")\n    ",
      "framework_requirements": {
        "python": ">=3.7"
      }
    }
  },
  "level2": {
    "passed": true,
    "issues": [],
    "contract": {
      "entry_point": "payload.py",
      "inputs": {
        "model_input": {
          "path": "/opt/ml/processing/input/model"
        }
      },
      "outputs": {
        "payload_sample": {
          "path": "/opt/ml/processing/output"
        }
      },
      "arguments": {},
      "environment_variables": {
        "required": [],
        "optional": {
          "CONTENT_TYPES": "application/json",
          "DEFAULT_NUMERIC_VALUE": "0.0",
          "DEFAULT_TEXT_VALUE": "DEFAULT_TEXT"
        }
      },
      "description": "\n    MIMS payload generation script that:\n    1. Extracts hyperparameters from model artifacts (model.tar.gz or directory)\n    2. Creates model variable list from field information\n    3. Generates sample payloads in multiple formats (JSON, CSV)\n    4. Archives payload files for deployment\n    \n    Note: This script extracts pipeline name, version, and model objective from hyperparameters,\n    not from environment variables. It does not use PIPELINE_NAME, REGION, PAYLOAD_S3_KEY, or \n    BUCKET_NAME environment variables.\n    \n    Input Structure:\n    - /opt/ml/processing/input/model: Model artifacts containing hyperparameters.json\n    \n    Output Structure:\n    - /tmp/mims_payload_work/payload_sample/: Sample payload files (temporary)\n    - /opt/ml/processing/output/: Output directory containing payload.tar.gz file\n    \n    Environment Variables:\n    - CONTENT_TYPES: Comma-separated list of content types (default: \"application/json\")\n    - DEFAULT_NUMERIC_VALUE: Default value for numeric fields (default: \"0.0\")\n    - DEFAULT_TEXT_VALUE: Default value for text fields (default: \"DEFAULT_TEXT\")\n    - SPECIAL_FIELD_<fieldname>: Custom values for specific fields\n    \n    Arguments:\n    - mode: Operating mode for the script (default: \"standard\")\n    ",
      "framework_requirements": {
        "python": ">=3.7"
      }
    },
    "specifications": {
      "payload_spec": {
        "step_type": "Payload",
        "node_type": "internal",
        "dependencies": [
          {
            "logical_name": "model_input",
            "dependency_type": "model_artifacts",
            "required": true,
            "compatible_sources": [
              "ModelStep",
              "TrainingStep",
              "XGBoostTraining"
            ],
            "data_type": "S3Uri",
            "description": "Trained model artifacts for payload generation"
          }
        ],
        "outputs": [
          {
            "logical_name": "payload_sample",
            "output_type": "processing_output",
            "property_path": "properties.ProcessingOutputConfig.Outputs['payload_sample'].S3Output.S3Uri",
            "data_type": "S3Uri",
            "description": "Generated payload samples archive (payload.tar.gz)"
          }
        ]
      }
    },
    "unified_specification": {
      "primary_spec": {
        "step_type": "Payload",
        "node_type": "internal",
        "dependencies": [
          {
            "logical_name": "model_input",
            "dependency_type": "model_artifacts",
            "required": true,
            "compatible_sources": [
              "ModelStep",
              "TrainingStep",
              "XGBoostTraining"
            ],
            "data_type": "S3Uri",
            "description": "Trained model artifacts for payload generation"
          }
        ],
        "outputs": [
          {
            "logical_name": "payload_sample",
            "output_type": "processing_output",
            "property_path": "properties.ProcessingOutputConfig.Outputs['payload_sample'].S3Output.S3Uri",
            "data_type": "S3Uri",
            "description": "Generated payload samples archive (payload.tar.gz)"
          }
        ]
      },
      "variants": {
        "generic": {
          "step_type": "Payload",
          "node_type": "internal",
          "dependencies": [
            {
              "logical_name": "model_input",
              "dependency_type": "model_artifacts",
              "required": true,
              "compatible_sources": [
                "ModelStep",
                "TrainingStep",
                "XGBoostTraining"
              ],
              "data_type": "S3Uri",
              "description": "Trained model artifacts for payload generation"
            }
          ],
          "outputs": [
            {
              "logical_name": "payload_sample",
              "output_type": "processing_output",
              "property_path": "properties.ProcessingOutputConfig.Outputs['payload_sample'].S3Output.S3Uri",
              "data_type": "S3Uri",
              "description": "Generated payload samples archive (payload.tar.gz)"
            }
          ]
        }
      },
      "unified_dependencies": {
        "model_input": {
          "logical_name": "model_input",
          "dependency_type": "model_artifacts",
          "required": true,
          "compatible_sources": [
            "ModelStep",
            "TrainingStep",
            "XGBoostTraining"
          ],
          "data_type": "S3Uri",
          "description": "Trained model artifacts for payload generation"
        }
      },
      "unified_outputs": {
        "payload_sample": {
          "logical_name": "payload_sample",
          "output_type": "processing_output",
          "property_path": "properties.ProcessingOutputConfig.Outputs['payload_sample'].S3Output.S3Uri",
          "data_type": "S3Uri",
          "description": "Generated payload samples archive (payload.tar.gz)"
        }
      },
      "dependency_sources": {
        "model_input": [
          "generic"
        ]
      },
      "output_sources": {
        "payload_sample": [
          "generic"
        ]
      },
      "variant_count": 1
    }
  },
  "level3": {
    "passed": true,
    "issues": [],
    "specification": {
      "step_type": "Payload",
      "node_type": "internal",
      "dependencies": [
        {
          "logical_name": "model_input",
          "dependency_type": "model_artifacts",
          "required": true,
          "compatible_sources": [
            "ModelStep",
            "TrainingStep",
            "XGBoostTraining"
          ],
          "data_type": "S3Uri",
          "description": "Trained model artifacts for payload generation"
        }
      ],
      "outputs": [
        {
          "logical_name": "payload_sample",
          "output_type": "processing_output",
          "property_path": "properties.ProcessingOutputConfig.Outputs['payload_sample'].S3Output.S3Uri",
          "data_type": "S3Uri",
          "description": "Generated payload samples archive (payload.tar.gz)"
        }
      ]
    }
  },
  "level4": {
    "passed": true,
    "issues": [
      {
        "severity": "WARNING",
        "category": "configuration_fields",
        "message": "Required configuration field not accessed in builder: source_model_inference_output_variable_list",
        "details": {
          "field_name": "source_model_inference_output_variable_list",
          "builder": "payload"
        },
        "recommendation": "Access required field source_model_inference_output_variable_list in builder or make it optional"
      },
      {
        "severity": "WARNING",
        "category": "configuration_fields",
        "message": "Required configuration field not accessed in builder: model_registration_domain",
        "details": {
          "field_name": "model_registration_domain",
          "builder": "payload"
        },
        "recommendation": "Access required field model_registration_domain in builder or make it optional"
      },
      {
        "severity": "WARNING",
        "category": "configuration_fields",
        "message": "Required configuration field not accessed in builder: model_registration_objective",
        "details": {
          "field_name": "model_registration_objective",
          "builder": "payload"
        },
        "recommendation": "Access required field model_registration_objective in builder or make it optional"
      },
      {
        "severity": "WARNING",
        "category": "configuration_fields",
        "message": "Required configuration field not accessed in builder: max_latency_in_millisecond",
        "details": {
          "field_name": "max_latency_in_millisecond",
          "builder": "payload"
        },
        "recommendation": "Access required field max_latency_in_millisecond in builder or make it optional"
      },
      {
        "severity": "WARNING",
        "category": "configuration_fields",
        "message": "Required configuration field not accessed in builder: expected_tps",
        "details": {
          "field_name": "expected_tps",
          "builder": "payload"
        },
        "recommendation": "Access required field expected_tps in builder or make it optional"
      },
      {
        "severity": "WARNING",
        "category": "configuration_fields",
        "message": "Required configuration field not accessed in builder: model_owner",
        "details": {
          "field_name": "model_owner",
          "builder": "payload"
        },
        "recommendation": "Access required field model_owner in builder or make it optional"
      },
      {
        "severity": "WARNING",
        "category": "configuration_fields",
        "message": "Required configuration field not accessed in builder: source_model_inference_input_variable_list",
        "details": {
          "field_name": "source_model_inference_input_variable_list",
          "builder": "payload"
        },
        "recommendation": "Access required field source_model_inference_input_variable_list in builder or make it optional"
      },
      {
        "severity": "INFO",
        "category": "required_field_validation",
        "message": "Builder has required fields but no explicit validation logic detected",
        "details": {
          "required_fields": [
            "source_model_inference_output_variable_list",
            "model_registration_objective",
            "max_latency_in_millisecond",
            "expected_tps",
            "model_registration_domain",
            "model_owner",
            "source_model_inference_input_variable_list"
          ],
          "builder": "payload"
        },
        "recommendation": "Consider adding explicit validation logic for required configuration fields"
      }
    ],
    "builder_analysis": {
      "config_accesses": [],
      "validation_calls": [],
      "default_assignments": [],
      "class_definitions": [
        {
          "class_name": "PayloadStepBuilder",
          "line_number": 30
        }
      ],
      "method_definitions": [
        {
          "method_name": "__init__",
          "line_number": 38
        },
        {
          "method_name": "validate_configuration",
          "line_number": 81
        },
        {
          "method_name": "_create_processor",
          "line_number": 111
        },
        {
          "method_name": "_get_environment_variables",
          "line_number": 138
        },
        {
          "method_name": "_get_inputs",
          "line_number": 173
        },
        {
          "method_name": "_get_outputs",
          "line_number": 226
        },
        {
          "method_name": "_get_job_arguments",
          "line_number": 281
        },
        {
          "method_name": "create_step",
          "line_number": 298
        }
      ]
    },
    "config_analysis": {
      "class_name": "PayloadConfig",
      "fields": {
        "model_owner": {
          "type": "<class 'str'>",
          "required": true
        },
        "model_registration_domain": {
          "type": "<class 'str'>",
          "required": true
        },
        "model_registration_objective": {
          "type": "<class 'str'>",
          "required": true
        },
        "source_model_inference_output_variable_list": {
          "type": "typing.Dict[str, str]",
          "required": true
        },
        "source_model_inference_input_variable_list": {
          "type": "typing.Union[typing.Dict[str, str], typing.List[typing.List[str]]]",
          "required": true
        },
        "expected_tps": {
          "type": "<class 'int'>",
          "required": true
        },
        "max_latency_in_millisecond": {
          "type": "<class 'int'>",
          "required": true
        },
        "framework": {
          "type": "<class 'str'>",
          "required": false
        },
        "processing_entry_point": {
          "type": "<class 'str'>",
          "required": false
        },
        "source_model_inference_content_types": {
          "type": "typing.List[str]",
          "required": false
        },
        "source_model_inference_response_types": {
          "type": "typing.List[str]",
          "required": false
        },
        "max_acceptable_error_rate": {
          "type": "<class 'float'>",
          "required": false
        },
        "default_numeric_value": {
          "type": "<class 'float'>",
          "required": false
        },
        "default_text_value": {
          "type": "<class 'str'>",
          "required": false
        },
        "special_field_values": {
          "type": "typing.Optional[typing.Dict[str, str]]",
          "required": false
        },
        "_VALID_TYPES": {
          "type": "typing.ClassVar[typing.List[str]]",
          "required": false
        }
      },
      "required_fields": [
        "expected_tps",
        "max_latency_in_millisecond",
        "model_owner",
        "model_registration_domain",
        "model_registration_objective",
        "source_model_inference_input_variable_list",
        "source_model_inference_output_variable_list"
      ],
      "optional_fields": [
        "_VALID_TYPES",
        "default_numeric_value",
        "default_text_value",
        "framework",
        "max_acceptable_error_rate",
        "processing_entry_point",
        "source_model_inference_content_types",
        "source_model_inference_response_types",
        "special_field_values"
      ],
      "default_values": {
        "aws_region": "<property>",
        "effective_instance_type": "<property>",
        "effective_source_dir": "<property>",
        "model_computed_fields": {},
        "model_config": {
          "arbitrary_types_allowed": true,
          "extra": "allow",
          "protected_namespaces": [],
          "validate_assignment": false,
          "json_encoders": {
            "<class 'pathlib.Path'>": "str"
          }
        },
        "model_extra": "<property>",
        "model_fields": {
          "author": "annotation=str required=True description='Author or owner of the pipeline.'",
          "bucket": "annotation=str required=True description='S3 bucket name for pipeline artifacts and data.'",
          "role": "annotation=str required=True description='IAM role for pipeline execution.'",
          "region": "annotation=str required=True description='Custom region code (NA, EU, FE) for internal logic.'",
          "service_name": "annotation=str required=True description='Service name for the pipeline.'",
          "pipeline_version": "annotation=str required=True description='Version string for the SageMaker Pipeline.'",
          "model_class": "annotation=str required=False default='xgboost' description='Model class (e.g., XGBoost, PyTorch).'",
          "current_date": "annotation=str required=False default_factory=<lambda> description='Current date, typically used for versioning or pathing.'",
          "framework_version": "annotation=str required=False default='2.1.0' description='Default framework version (e.g., PyTorch).'",
          "py_version": "annotation=str required=False default='py310' description='Default Python version.'",
          "source_dir": "annotation=Union[str, NoneType] required=False default=None description='Common source directory for scripts if applicable. Can be overridden by step configs.'",
          "processing_instance_count": "annotation=int required=False default=1 description='Instance count for processing jobs' metadata=[Ge(ge=1), Le(le=10)]",
          "processing_volume_size": "annotation=int required=False default=500 description='Volume size for processing jobs in GB' metadata=[Ge(ge=10), Le(le=1000)]",
          "processing_instance_type_large": "annotation=str required=False default='ml.m5.4xlarge' description='Large instance type for processing step.'",
          "processing_instance_type_small": "annotation=str required=False default='ml.m5.2xlarge' description='Small instance type for processing step.'",
          "use_large_processing_instance": "annotation=bool required=False default=False description='Set to True to use large instance type, False for small instance type.'",
          "processing_source_dir": "annotation=Union[str, NoneType] required=False default=None description='Source directory for processing scripts. Falls back to base source_dir if not provided.'",
          "processing_entry_point": "annotation=str required=False default='payload.py' description='Entry point script for payload generation'",
          "processing_script_arguments": "annotation=Union[List[str], NoneType] required=False default=None description='Optional arguments for the processing script.'",
          "processing_framework_version": "annotation=str required=False default='1.2-1' description=\"Version of the scikit-learn framework to use in SageMaker Processing. Format: '<sklearn-version>-<build-number>'\"",
          "model_owner": "annotation=str required=True description='Team ID of model owner'",
          "model_registration_domain": "annotation=str required=True description='Domain for model registration'",
          "model_registration_objective": "annotation=str required=True description='Objective of model registration'",
          "source_model_inference_output_variable_list": "annotation=Dict[str, str] required=True description='Dictionary of output variables and their types (NUMERIC or TEXT)'",
          "source_model_inference_input_variable_list": "annotation=Union[Dict[str, str], List[List[str]]] required=True description=\"Input variables and their types. Can be either:\\n1. Dictionary: {'var1': 'NUMERIC', 'var2': 'TEXT'}\\n2. List of pairs: [['var1', 'NUMERIC'], ['var2', 'TEXT']]\"",
          "expected_tps": "annotation=int required=True description='Expected transactions per second' metadata=[Ge(ge=1)]",
          "max_latency_in_millisecond": "annotation=int required=True description='Maximum acceptable latency in milliseconds' metadata=[Ge(ge=100), Le(le=10000)]",
          "framework": "annotation=str required=False default='xgboost' description='ML framework used for the model'",
          "source_model_inference_content_types": "annotation=List[str] required=False default=['text/csv'] description=\"Content type for model inference input. Must be exactly ['text/csv'] or ['application/json']\"",
          "source_model_inference_response_types": "annotation=List[str] required=False default=['application/json'] description=\"Response type for model inference output. Must be exactly ['text/csv'] or ['application/json']\"",
          "max_acceptable_error_rate": "annotation=float required=False default=0.2 description='Maximum acceptable error rate (0-1)' metadata=[Ge(ge=0.0), Le(le=1.0)]",
          "default_numeric_value": "annotation=float required=False default=0.0 description='Default value for numeric fields'",
          "default_text_value": "annotation=str required=False default='DEFAULT_TEXT' description='Default value for text fields'",
          "special_field_values": "annotation=Union[Dict[str, str], NoneType] required=False default=None description='Optional dictionary of special TEXT fields and their template values'"
        },
        "model_fields_set": "<property>",
        "pipeline_description": "<property>",
        "pipeline_name": "<property>",
        "pipeline_s3_loc": "<property>",
        "sample_payload_s3_key": "<property>",
        "script_contract": "<property>",
        "script_path": "<property>"
      }
    }
  },
  "overall_status": "PASSING",
  "metadata": {
    "script_path": "/Users/tianpeixie/github_workspace/cursus/src/cursus/steps/scripts/payload.py",
    "contract_mapping": "payload_contract",
    "validation_timestamp": "2025-08-11T21:12:34.232260",
    "validator_version": "1.0.0"
  }
}